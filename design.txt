''' Arielle Slatus
    CS5001
    Homework 7
    December 5, 2019

    Design
'''

- The functionality of my adventure game is encapsulated in its own class, called "Game." This class reads data files and creates objects from them using methods get_items(), get_rooms, and read_puzzles. These objects are then stored as lists within __init__(). 

- The game begins when the Game method walking_around is called. This method runs the heart of the game. When it is first called, the starting room is set to the courtyard, the inventory is initialized as an empty list, and the inventory weight and points are set to zero. These variables will all be manipulated throughout the game as the player takes or drops items, moves around rooms, and accumulates points. The rest of walking_around is held is a while loop that is set to run as long as play = True. When the player eventually wants to quit, play becomes false, the loop is broken, and the player's final point count is reported to them. This method continually updates the player of their surroundings and prompts the player with a menu of actions that they may take. Depending on their input, a series of other methods are called to implement their choice. 

- If the player indicates that they wish to move north, south, east, or west, a method named walk is called. This method first determines the direction that the player wants to walk in and compares it to the adjacent_rooms held by the current room object. If the player wants to travel north, the method compares the first element in the adjacent_rooms list. If they wish to travel south, the method compares the second element in adjacent_rooms. If east, the third element. If west, the fourth element.	
	- If that element is greater than 0, the enter_new_room() method is called, which passes the value of adjacent_rooms[0] and uses it to get the room number of the new room being entered. That new room object is returned to walk, which is then returned to walking_around(). 
	- If the element is less then 0, the blocked_path() method is called. This method takes the current room as a parameter and deciphers what puzzle or monster is blocking the player's path. This information is reported back to the player and the same room is returned.
	- Lastly, if the element is equal to 0, the wrong_direction() method is called, which simply reports to the player that they cannot move in said direction and returns the same room object.

- If the player wants to look at an item, walking_around() calls the method look(). This method ask the player which item in the room they wish to look at. If the player's input is not the name of an item in the room, then they are informed so. If the player's input is the name of an item in the room, then the item object's description is returned to walking_around(), where it is then printed for the user to read.

- If the player wants to take an item in the room, the take_item() method is called. This method first asks the play which item in the room they would like to take. If the player's input is not the name of an item in the room, they are informed so and take_item() returns an empty string back to walking_around, which only appends the returned value of take_item() if its value is not an empty string. If the player inputs the name of an item object that is in fact in the room, that item object is returned to walking_around().
	- After the item is returned, walking_around() calls upon the method check_weight() to determine whether the player will be able to carry this new item. The maximum weight that a player can hold is 10 units. If the player's current inventory_weight plus the new item object's weight exceeds 10 units, then check_weight() returns the unchanged inventory weight and the boolean value False. If the addition of the item's weight does not make the inventory weight too heavy, then the item's weight is added to the existing inventory weight and this new total weight is returned, along with the boolean value True. 
	- If check_weight returns False to walking_around(), the player is informed that they are carrying too much weight to take on this additional item. If check_weight() returns True, then the item object is appended to the player's inventory list, the point value of that item is added to the points counter, and the item object is removed from the room object. The player's success is reported to them.

- If the player wants to use an item, the use_item() method is called. This method first asks the player which item in their inventory they would like to use. If their input is not the name of an item in their inventory, they are informed so. Otherwise, use_item then check to make sure the item has_use_remaining(). If it does have use remaining, then the method moves forward with using the item. If the item solves a puzzle, the player is informed so and the method calls upon the room to reverse_effects(), which makes any negative number in that room's adjacent_rooms now positive. The method then returns the room's new adjacent_rooms. Now that the puzzle has been solved, a more complete description of the room is now printed for the user to read. If use of the item does not solve a puzzle, the item has not use remaining, or the item is not in the player's inventory, then the player is informed so and an empty string is returned. 

- If the player wants to drop an item that they have been carrying in their inventory, walking_around() asks the player which item in their inventory they would like to drop, and their response is passed into the drop_item() method. If their response is not the name of an item in their inventory, they are informed so and an empty string is returned, along with an unchanged inventory_weight. If the user's response is the name of an item in their inventory, then that item object is removed from the inventory list. The same item object is then added to the current room object. The inventory_weight is updated by subtracting that of the item that has been dropped. The dropped item object and new inventory_weight are returned to walking_around(), which informs the player of their success in dropping the item, as long as the value of the item dropped is not an empty string.

- If the player wants to view a list of the items in their inventory, walking_around() calls the method print_inventory(). If there are no items in the player's current inventory, they are informed so. Otherwise, the names of each item object that the player is carrying is printed for them to read.

Testing:

	I ran continuous testing on my adventure game as I was writing it. I was consistently putting myself in the player's shoes by not just running through the game as it is supposed to work, but by thinking about what mistakes a player might likely make. For each instance where the game asks the player for input, I checked to see what would happen if I made a typo or entered the name of an object that was not in the room. I was meticulous about looking for ways to crash the game by entering invalid responses. This helped me determine how to communicate stipulations to the player when they attempt taking "illegal" actions. Using mostly print statements, I was able to determine clarify that items were being moved about correctly, rooms were being navigated appropriately, and that puzzles were being deactivated successfully. Through unit testing, I was able to debug an early issue with my drop_item() method, in which I had mistakenly written the method to reset the inventory_weight to zero if an item was too heavy to pick up. Upon realizing this, I altered my code so that now if an item is too heavy, the inventory_weight remains the same. 
